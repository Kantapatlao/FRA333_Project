# **FRA333 Class Project: Path finding and position trajectory generation to avoid collision in 3 DOF Planar Revolute robot**

โครงงานนี้ถูกจัดทำขึ้นเพื่อใช้ในการศึกษาและพัฒนาการสร้างวิถีการเคลื่อนที่ (Trajectory Generation) สำหรับหุ่นยนต์ 3 DOF Planar revolute robot ที่สามารถหลบหลีกสิ่งกีดขวางภายในพื้นที่ทำงาน (Task Space) ได้ โดยการจำลองการเคลื่อนที่และลักษณะของหุ่น ผ่านการใช้ Python และอัลกอริทึมที่ใช้ในการค้นหาเส้นทาง (Path finding) ผลลัพท์ที่คาดหวังคือโปรแกรมจำลองแขนกล 3 DOF ที่สามารถเคลื่อนที่ไปยังเป้าหมายได้โดยหลีกเลี่ยงการชนสิ่งกีดขวางตามข้อกำหนดในขั้นตอนการวางแผนวิถี (Trajectory planning)
การทดสอบจะดำเนินการผ่านการจำลองด้วย Pygame ที่จะแสดงให้เห็นถึงการเคลื่อนที่ในพื่นที่ทำงานที่มีสิ่งกีดขวางหลากหลายรูปแบบ มี่ใช้เป็นเกฯฑ์ให้เห็นภาพในการทดสอบ

# Table of Contents
- [จุดประสงค์โครงการ](#จุดประสงค์โครงการ)
- [System Overview](#system-overview)
- [โปรแกรมละหลักการทำงาน](#โปรแกรมละหลักการทำงาน)
  - [map_generator.ipynb](#map_generatoripynb)
  - [map_optimizer.py](#map_optimizerpy)
- [การใช้งานโปรแกรม](#การใช้งานโปรแกรม)
- [ผลการทดลอง](#ผลการทดลอง)
- [สรุปและวิเคราะห์ผล](#สรุปและวิเคราะห์ผล)
- [เอกสารอ้างอิง](#เอกสารอ้างอิง)

# **จุดประสงค์โครงการ**
1)	เพื่อศึกษาการเคลื่อนที่ของแขนกลแบบ Revolute ในปริภูมิ 2 มิติ  
2)	เพื่อศึกษาวิธีการสร้างวิถีการโคจรให้แขนกลเคลื่อนที่ไปยังเป้าหมายในขณะที่มีสิ่งกีดขวาง
3)	เพื่อศึกษาการทำ Path finding และ Trajectory planning สำหรับการสร้างวิถีโคจรที่หลบหลีกสิ่งกีดขวางและไปยังเป้าหมาย

**ขอบเขต**
1)  ตัวหุ่นยนต์
  - กำหนดให้ทุก ๆ ก้านของแขนกลเป็น Rigid body ที่มีเพียงความยาวเท่านั้น ไม่มีความกว้างและลึก
  - แขนกลเป็น Joint แบบ Revolute จำนวน 3 Joints (RRR Robot)
  - แต่ละก้านของแขนกลมีความยาวเท่ากัน
  - ตำแหน่งเริ่มต้น (Home) เหมือนกันทุกการทำงาน
  - พิจารณาเฉพาะ Kinematic (ไม่มีการจำลองหรือพิจารณาแรงภายนอก)
  - Simulation รับ input เป็น:
    - ตำแหน่งฐานปัจจุบันของ Robot arm
    - ตำแหน่งของ End-effector ณ จุดเริ่มต้น
    - จุดพิกัดที่ต้องการให้ End-effector
2) แผนที่และสิ่งกีดขวาง
  - ระบบรู้สภาพแวดล้อมทั้งหมดก่อนเริ่มทำ Path planning
  - แผนที่มีขนาดเท่ากันทุกแผนที่
  - ขอบของแผนที่นับเป็นสิ่งกีดขวาง
  - สิ่งกีดขวางและเป้าหมายจะไม่มีการย้ายตำแหน่งขณะกำลังแสดงผล
  - สิ่งกีดขวางจะแสดงผลเป็นพื้นที่สีดำบนแผนที่
  - ตำแหน่งเป้าหมายจะอยู่ในพื้นที่แผนที่และไม่อยู่บนสิ่งกีดขวาง
  - Simulation รับ input เป็นแผนที่สภาพแวดล้อมที่ระบุสิ่งกีดขวาง
3) การแสดงผล
  - ใช้ Pygame ในการแสดงผลการเคลื่อนที่
  - Output ของ Simulation เป็น:
    - พิกัด via point
    - การจำลองการเคลื่อนที่ผ่าน Pygame
    - จำลองการเคลื่อนที่ภายใน Simulation ด้วยภาษา Python


# **System Overview**

รอภาพพพพพพพพพพพพพพพ


# **โปรดลง Library พวกนี้ก่อนรัน**
  - numpy
  - math
  - roboticstoolbox

**ลงโดยใช้ Command พวกนี้**
```bash
  - pip install numpy==1.24.4
  - pip install math
  - pip install pygame
```
**Clone Project**
ใช้ Command นี้
```bash
  - gh repo clone Kantapatlao/FRA333_Project
```
# **โปรแกรมละหลักการทำงาน**
## map_generator.ipynb

คือโปรแกรมที่ใช้ในการสร้างแผนที่ โดย

**make_map()** \
เป็นฟังค์ชั่นสร้างแผนที่แบบกริด (Grid map) โดยกำหนดขนาดใน sizeX และ sizeY จากนั้นเพิ่มสิ่งกีดขวางตามจำนวนที่ระบุใน obstacles_count หากไม่ได้ระบุ obstacles_count ฟังก์ชันจะสุ่มจำนวนสิ่งกีดขวางระหว่าง 1 ถึง 5 และวางไว้ในแผนที่ สิ่งกีดขวางจะถูกวางในตำแหน่งสุ่มภายในแผนที่ พร้อมขนาดและรูปร่างแบบสุ่ม
- **รูปแบบคำสั่ง**
```
make_map(sizeX, sizeY, obstacles_count)
```
- **พารามิเตอร์**
    - sizeX, sizeY: ขนาดของกริดแผนที่ ทั้งสองค่าต้องเป็น จำนวนเต็มบวก (unsigned integer) เท่านั้น ฟังก์ชันนี้ไม่แปลงชนิดตัวแปรให้อัตโนมัติ
    - obstacles_count: จำนวนสิ่งกีดขวางที่วางในแผนที่ ต้องเป็น จำนวนเต็มบวก (unsigned integer) เท่านั้น ฟังก์ชันนี้ไม่แปลงชนิดตัวแปรให้อัตโนมัติ โดย obstacles_count สามารถละเว้นได้ และฟังก์ชันจะสุ่มทำการจำนวนสิ่งกีดขวางตั้งแต่ 1 ถึง 5 เพื่อวางภายในแผนที่

- **ค่าที่ส่งกลับมา**\
    จะคืนค่าแผนที่ 2 มิติในรูปแบบของ numpy.ndarray ขนาดตามที่ระบุใน sizeX และ sizeY โดยเส้นทางที่สามารถเดินได้จะถูกแทนด้วยค่า 0 และสิ่งกีดขวางจะแทนด้วยค่า 1

- **ตัวอย่างแผนที่ที่ได้ออกมา**\
    รอภาพพพพพพพพพพพพพพพพพพพพพพพพพพพพพพพพ

## map_optimizer.py
ใช้ปรับแต่งแผนที่ที่ไดมาจาก map_generator โดย\
**BT_Node()**\
เป็นคลาสที่ใช้สำหรับแบ่งแผนที่กริดที่ได้มาเป็นส่วนย่อยๆ
- **รูปแบบคำสั่ง**
```
BT_Node(self, data_in, posX_in, posY_in)
```
- **คุณลักษณะ**
  - data: ข้อมูลของโหนด (อาจเก็บข้อมูลในรูปแบบ ndarray สำหรับแผนที่กริด หรือ Discrete_map)
  - posX: พิกัด X ของโหนด (ใช้เฉพาะในระหว่างการแบ่งแผนที่ เมื่อการแบ่งแผนที่เสร็จสมบูรณ์แล้ว คุณสมบัตินี้จะไม่ได้ใช้งาน)
  - posY: พิกัด Y ของโหนด (ใช้เฉพาะในระหว่างการแบ่งแผนที่ เมื่อการแบ่งแผนที่เสร็จสมบูรณ์แล้ว คุณสมบัตินี้จะไม่ได้ใช้งาน)
  - childA, childB: โหนดลูกของ Binary Tree Node ปัจจุบัน แต่ละโหนดจะเก็บออบเจ็กต์ BT_Node เพียงหนึ่งตัว
- **ตัวอย่างการใช้งาน**
```
A = BT_Node(np.zeros((5,5)), 10, 10)
```
- **ค่าที่ส่งกลับมา**\
เป็น Binary Tree Node คือเป็นออบเจ็กต์ที่ใช้จัดการข้อมูลแบบลำดับชั้น

**Discrete map()**\
เป็นคลาสที่ใช้แทนส่วนหนึ่งของแผนที่ที่ไม่ต่อเนื่องกัน(Discrete Map)โดยแทนที่การอธิบายแต่ละพิกัดว่าเป็นสิ่งกีดขวางหรือไม่ด้วยการรวมพิกัดที่มีสถานะเดียวกันเข้าด้วยกันในรูปของสี่เหลี่ยมที่ทราบตำแหน่งและขนาด
- **รูปแบบคำสั่ง**
```
DM = Discrete_map(1,10,20,15,25)
```
- **คุณลักษณะ**
  - value: เก็บค่าที่ระบุว่า Discrete Map ปัจจุบันเป็นสิ่งกีดขวาง (1) หรือเส้นทางว่าง (0)
  - posX, posY: เก็บพิกัดมุมซ้ายบนของ Discrete Map ปัจจุบัน
  - sizeX, sizeY: เก็บความกว้างและความสูงของ Discrete Map ปัจจุบัน
- **ค่าที่ส่งกลับมา**\
  เป็น Node ของแผนที่ส่วนที่ไม่ต่อเนื่องกัน
  
ภายในคลาส Discrete map() ประกอบไปด้วยฟังค์ชั่น ดังนี้
```
get_center_pos(self)
get-bottonm_right_pos(self)
scale_discrete_map(self, scale, x_offset, y_offset)
```
  - get_center_pos(self): ส่งคืนค่าตำแหน่งศูนย์กลางของ Discrete map
  - get-bottonm_right_pos(self): ส่งคืนค่าตำแหน่งมุมขวาล่างของ Discrete map
  - scale_discrete_map(self): ส่งคือ discrete map ใไม่ที่ปรับขนาดตามค่าที่กำหนด

**Map(self, in_map)**\
เป็นคลาสที่ใช้สำหรับเก็บและคำนวณแผนที่กริดปกติ (Normal Grid Map) ให้เป็นแผนที่กริดแบบไม่ต่อเนื่อง (Discrete Grid Map) โดยในขั้นตอนการเริ่มต้น (Initialization) จะรับแผนที่กริดในรูปแบบ numpy.ndarray จากนั้นจะคำนวณให้เป็นแผนที่แบบไม่ต่อเนื่อง และจัดเก็บผลลัพธ์ไว้ในคลาส
- **รูปแบบคำสั่ง**
```
M = Map(np.zeros((10,10)))
```
- **คุณลักษณะ**
  - full_map: เก็บแผนที่กริดทั้งหมดในรูปแบบ numpy.ndarray ซึ่งถูกป้อนเข้ามาในขั้นตอนการเริ่มต้นออบเจ็กต์
  - tree_map: ตัวเก็บข้อมูลชั่วคราวสำหรับ Binary Tree ที่ใช้ในการเปลี่ยนแผนที่กริดให้เป็นแผนที่แบบไม่ต่อเนื่อง (Discretized Map) คุณสมบัตินี้ไม่ควรถูกเรียกใช้งานจากภายนอกเมธอดของออบเจ็กต์
  - optimized_map: รายการของ discrete_map ที่แสดงถึงแผนที่กริดที่ป้อนเข้าไป ลำดับของ discrete_map อาจไม่เรียงตามลำดับ
  - obstacle_list: เก็บเฉพาะ discrete_map ที่มีค่าเป็น 1 (สิ่งกีดขวาง) ซึ่งซ้ำซ้อนกับฟังก์ชัน list_obstacle
- **พารามิเตอร์**
  - in_map: แผนที่กริดที่ป้อนเข้ามาในรูปแบบ numpy.ndarray โดยค่า 1 แสดงถึงสิ่งกีดขวาง (obstacle) และค่า 0 แสดงถึงเส้นทางว่าง (free path)

ภายในคลาส Map() ประกอบไปด้วยฟังค์ชั่น ดังนี้
```
find_adjacent_node(self, input_node) 
find_nearest_node(self, x, y)
list_obstacle(self)
show_graph(self)
```
  - find_adjacent_node(self, input_node):รับข้อมูลจาก Discrete map มาแล้วส่งคืนแมพที่ ขอบบน, ล่าง, ขวา, ซ้ายติดกัน 
  - find_nearest_node(self, x, y): จากพิกัดที่กำหนด ส่งคืน Discrete map ที่มีพิกัดที่กำหนดอยู่ภายใน
  - list_obstacle(self): ใน Map ปัจจุบัน ส่งคืนรายการของ Discrete map ที่มีค่าเป็น 1 (คือสิ่งกีดขวาง)
  - show_graph(self): จาก Map ปัจจุบัน พิมพ์ข้อมูลของแต่ละโหนด (Discrete map) และคุณสมบัติออกมา

**robot.py**

Robot: คลาสที่เป็บข้อมูลของข้อต่อ, ความยาวของก้าน และตำแหน่งฐาน ประกอบไปด้วย
  - set_base_position(): จากออบเจ็กต์ Map ปัจจุบัน พิมพ์ข้อมูลของแต่ละโหนด (Discrete map) และคุณสมบัติออกมา
  - forward_kinematic(): จากมุมของข้อต่อที่กำหนด อัปเดตออบเจ็กต์หุ่นยนต์ด้วยมุมและตำแหน่งที่คำนวณได้ของแต่ละส่วน และส่งคืนตำแหน่งสุดท้ายของแต่ละส่วน
  - sequencial_IK_3(): จากพิกัด X,Y ที่กำหนด คำนวณค่ามุมของข้อต่อสูงสุด 4 ชุดที่ทำให้ปลายแขนถึงพิกัดที่กำหนด ส่งคืนชุดค่ามุมข้อต่อที่คำนวณได้เป็นรายการ
  - check_wall_collision(): จากขนาดและตำแหน่งของแผนที่ ตรวจสอบว่าค่ามุมข้อต่อในปัจจุบันชนกับขอบของแผนที่หรือไม่
  - check_object_collision(): จาก Discrete map object ตรวจสอบว่าค่ามุมข้อต่อในปัจจุบันชนกับสิ่งกีดขวางใดๆ หรือไม่
  - draw_robot(): วาดหุ่นยนต์ลงในหน้าจอ pygame ตามค่ามุมข้อต่อปัจจุบัน สามารถกำหนดตำแหน่งฐานเพิ่มเติมได้ในฟังก์ชันนี้

**A_Star.py**
  A object*: ออบเจ็กต์สำหรับคำนวณด้วยอัลกอริธึม A* ให้ประกาศก่อนใช้งาน
  - compute_path(): รับพิกัดเป้าหมาย แผนที่ และออบเจ็กต์หุ่นยนต์ เพื่อคำนวณเส้นทางในรูปของลำดับของ _A_Star_Node ที่จะใช้ในการเคลื่อนที่

## **การใช้งานโปรแกรม**



## **ผลการทดลอง**
**Examples : Map1.npy**
[Watch the video](D:\ปี3\MLwithju\ML_project\20241209-0339-49.7498429.mp4)
The simulation begins with the robot arm in its home position and a known target point. The inverse kinematics approach is used to calculate the joint (q) values required to move the robot arm to the target position.

**Examples : Out of Reach**

pic ture 2"D:ปี3\MLwithju\results\2 out of reach.png"

**Examples : Spawn On Obstacle**
pic ture 3"D:ปี3\MLwithju\results\3"

**การตรวจสอบความถูกต้อง : Map1.npy**
สำหรับการตรวจสอบความถูกต้อง เราสามารถแสดงผลลัพธ์ได้โดยใช้ทั้ Forward kinematic และ Inverse kinematics ของแขนหุ่นยนต์ เพื่อคำนวณและตรวจสอบตำแหน่งเป้าหมาย

**การตรวจสอบความถูกต้อง : Calculate About Target**
สำหรับการตรวจสอบความถูกต้อง เราสามารถแสดงผลลัพธ์โดยใช้ทั้งการคำนวณ Forward kinematic และ Inverse kinematics ของแขนหุ่นยนต์เพื่อคำนวณและยืนยันตำแหน่งเป้าหมาย

## **สรุปและวิเคราะห์ผล**
จากการศึกษาและลองทำแบบจำลองการเคลื่อนที่ของแขนกลแบบ 3 DOF Relolue ในสองมิติและประยุกต์ใช้ร่วมกับการทำ Path finding และ Trajectory planning โดยใช้ A* Search algorithm พบว่าจากผลลัพธ์ที่ได้แขนของหุ่นยนต์สามารถเคลื่อนที่ไปยังเป้าหมายโดยไม่โดนสิ่งกีดขวางและเมื่อตำแหน่งเป้าหมายอยู่เกินระยะแแขนหรือไม่มีเส้นทางที่ไปได้โดยไม่ชนก็สามารถส่ง Feedback กลับมาได้  แต่ในบางแผนที่และบางตำแหน่งจะยังไม่สามารถเคลื่อนที่ไปได้ เนื่องจากสมการ Inverse kinematic ที่ใช้ในการคิดกลับมาหาตำแหน่ง joint จึงทำให้ Logic ที่เช็คระยะมีปัญหาไปด้วย ในส่วนของ A* Search algorithm ยังพิสูจน์ไม่ได้ว่า Path ที่สร้างข้นมานั้น Optimal

## **เอกสารอ้างอิง**
Recent advance in Rapidly – Exploring random tree: A review
https://www.sciencedirect.com/science/article/pii/S2405844024084822

A Systematic Literature Review of A* Pathfinding
https://www.sciencedirect.com/science/article/pii/S1877050921000399



